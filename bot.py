import os
import json
import re
import difflib
import asyncio
from datetime import datetime
from threading import Thread

from flask import Flask
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters

import gspread
from oauth2client.service_account import ServiceAccountCredentials

# ========== Google Sheets Setup ==========
scope = ["https://spreadsheets.google.com/feeds", 'https://www.googleapis.com/auth/drive']
creds_dict = json.loads(os.environ['GOOGLE_CREDENTIALS'])
creds = ServiceAccountCredentials.from_json_keyfile_dict(creds_dict, scope)
client = gspread.authorize(creds)

def get_data():
    sheet = client.open("–ü–µ—Ä–µ–¥–æ–≤–∏–∫ –≤–∞–∫–∞–Ω—Å–∏–∏ –ë–û–¢").sheet1
    return sheet.get_all_records()

def save_application_to_sheet(name, phone, vacancy, username):
    sheet = client.open_by_key("10TcAZPunK079FBN1gNQIU4XmInMEQ8Qz4CWeA6oDGvI")
    worksheet = sheet.worksheet("bot otkliki")
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    new_row = [now, name, phone, vacancy, f"@{username}" if username else "–±–µ–∑ username"]
    worksheet.append_row(new_row, value_input_option="USER_ENTERED")

# ========== Bot Logic ==========
STATE_WAITING_FOR_FIO = 1
STATE_WAITING_FOR_PHONE = 2

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [[InlineKeyboardButton("–ê–ö–¢–£–ê–õ–¨–ù–´–ï –í–ê–ö–ê–ù–°–ò–ò", callback_data="find_jobs")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ø–æ–¥–æ–±—Ä–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é. –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–π",
        reply_markup=reply_markup
    )

async def jobs(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = get_data()
    lines = [f"‚Ä¢ {line.strip()}" for row in data if row.get('–°–¢–ê–¢–£–°', '').strip().upper() == '–ù–ê–ë–ò–†–ê–ï–ú'
             for line in row['–í–∞–∫–∞–Ω—Å–∏—è'].splitlines()]
    text = "\n".join(lines)
    target = update.message or update.callback_query.message
    await target.reply_text("–°–ø–∏—Å–æ–∫ –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–π:\n\n" + text)
    await asyncio.sleep(1)
    await target.reply_text("–ö–∞–∫–∞—è –≤–∞–∫–∞–Ω—Å–∏—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?")

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.data == "find_jobs":
        await jobs(update, context)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.lower()
    data = get_data()
    matches = []
    for row in data:
        for line in row['–í–∞–∫–∞–Ω—Å–∏—è'].splitlines():
            if text in line.lower() or difflib.get_close_matches(text, [line.lower()], cutoff=0.6):
                matches.append(row)
                break
    if matches:
        context.user_data['vacancies'] = matches
        for i, row in enumerate(matches):
            description = row.get('–û–ø–∏—Å–∞–Ω–∏–µ', '').strip()
            description_text = f"\n\nüìÉ –û–ø–∏—Å–∞–Ω–∏–µ –≤–∞–∫–∞–Ω—Å–∏–∏:\n\n{description}" if description else ""
            response = f"""
üîß *{row['–í–∞–∫–∞–Ω—Å–∏—è']}*

üìà –ß–∞—Å–æ–≤–∞—è —Å—Ç–∞–≤–∫–∞: {row['–ß–∞—Å–æ–≤–∞—è —Å—Ç–∞–≤–∫–∞']}
üïê –í–∞—Ö—Ç–∞ 30/30 –ø–æ 12—á: {row['–í–∞—Ö—Ç–∞ –ø–æ 12 —á–∞—Å–æ–≤ (30/30)']}
üïë –í–∞—Ö—Ç–∞ 60/30 –ø–æ 11—á: {row['–í–∞—Ö—Ç–∞ –ø–æ 11 —á (60/30)']}
üìå –°—Ç–∞—Ç—É—Å: {row.get('–°–¢–ê–¢–£–°', '–Ω–µ —É–∫–∞–∑–∞–Ω')}{description_text}
"""
            keyboard = [
                [InlineKeyboardButton("–û–¢–ö–õ–ò–ö–ù–£–¢–¨–°–Ø", callback_data=f"apply_{i}"),
                 InlineKeyboardButton("–ù–ê–ó–ê–î", callback_data="back")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_markdown(response, reply_markup=reply_markup)
    else:
        await update.message.reply_text("–ù–µ –Ω–∞—à—ë–ª –≤–∞–∫–∞–Ω—Å–∏—é –ø–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –µ—ë –ø–æ–ª–Ω–µ–µ.")

async def back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    keyboard = [[InlineKeyboardButton("–ê–ö–¢–£–ê–õ–¨–ù–´–ï –í–ê–ö–ê–ù–°–ò–ò", callback_data="find_jobs")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.callback_query.message.reply_text(
        "–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ø–æ–¥–æ–±—Ä–∞—Ç—å –≤–∞–∫–∞–Ω—Å–∏—é. –ù–∞–ø–∏—à–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –∏–ª–∏ –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–ø–∏—Å–æ–∫ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –≤–∞–∫–∞–Ω—Å–∏–π",
        reply_markup=reply_markup
    )

async def handle_apply(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    index = int(query.data.split("_", 1)[1])
    data = context.user_data.get('vacancies') or get_data()
    if index >= len(data):
        await query.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –≤–∞–∫–∞–Ω—Å–∏—é.")
        return
    row = data[index]
    vacancy = row['–í–∞–∫–∞–Ω—Å–∏—è']
    context.user_data['vacancy'] = vacancy
    context.user_data['state'] = STATE_WAITING_FOR_FIO
    await query.answer()
    await query.message.edit_text(f"–í—ã –æ—Ç–∫–ª–∏–∫–Ω—É–ª–∏—Å—å –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é: {vacancy}\n\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –§–ò–û:")

async def handle_fio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    fio = update.message.text.strip()
    if not re.match(r"^[–ê-–Ø–∞-—è–Å—ë\s-]+$", fio):
        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω–æ–µ –§–ò–û. –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.")
        return
    context.user_data['fio'] = fio
    context.user_data['state'] = STATE_WAITING_FOR_PHONE
    await update.message.reply_text("–¢–µ–ø–µ—Ä—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:")

async def handle_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    phone = update.message.text.strip()
    if not re.match(r"^[\d+\(\)\- ]+$", phone):
        await update.message.reply_text("–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞.")
        return
    context.user_data['phone'] = phone
    username = update.message.from_user.username
    save_application_to_sheet(
        context.user_data['fio'],
        context.user_data['phone'],
        context.user_data['vacancy'],
        username
    )
    await update.message.reply_text(f"–í–∞—à –æ—Ç–∫–ª–∏–∫ –Ω–∞ –≤–∞–∫–∞–Ω—Å–∏—é {context.user_data['vacancy']} –ø—Ä–∏–Ω—è—Ç!\n"
                                    f"–§–ò–û: {context.user_data['fio']}\n"
                                    f"–¢–µ–ª–µ—Ñ–æ–Ω: {context.user_data['phone']}\n\n"
                                    "–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∫–ª–∏–∫!")
    context.user_data['state'] = None

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    state = context.user_data.get('state')
    if state == STATE_WAITING_FOR_FIO:
        await handle_fio(update, context)
    elif state == STATE_WAITING_FOR_PHONE:
        await handle_phone(update, context)
    else:
        await handle_message(update, context)

# ========== Flask Keep-Alive ==========
flask_app = Flask(__name__)

@flask_app.route('/')
def index():
    return "Bot is alive!"

def run_flask():
    flask_app.run(host="0.0.0.0", port=8080)

# ========== Run Telegram Bot ==========
if __name__ == '__main__':
    # Flask –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    Thread(target=run_flask, daemon=True).start()

    # Telegram bot –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –≤ –≥–ª–∞–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    app = ApplicationBuilder().token(os.environ["BOT_TOKEN"]).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("jobs", jobs))
    app.add_handler(CallbackQueryHandler(handle_callback, pattern="find_jobs"))
    app.add_handler(CallbackQueryHandler(handle_apply, pattern=r"apply_\d+"))
    app.add_handler(CallbackQueryHandler(back, pattern="back"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
    
    # –í–∞–∂–Ω–æ: –∑–∞–ø—É—Å–∫ –≤ –≥–ª–∞–≤–Ω–æ–º –ø–æ—Ç–æ–∫–µ!
    app.run_polling()
